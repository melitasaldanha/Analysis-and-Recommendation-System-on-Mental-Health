# -*- coding: utf-8 -*-
"""Regression_Analysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Vo026bLaUe6-JjAVto1Dv7x_Mlb1LgGB
"""

# Usage Regression_Analysis.py 'target_file_name' 'feature_file_name' 'target_col'

import numpy as np
import pandas as pd
from sklearn.utils import shuffle
from sklearn.metrics import mean_absolute_e
from scipy.stats import pearsonr, zscore
import tensorflow.compat.v1 as tf
tf.disable_v2_behavior()

def get_betas_for_df(feature_df, target_df, target_col):
    
    # Preprocess data to create features and targets
    target_df = depression_df[['SEQN',target_col ]]
    df_merge = pd.merge(target_df, feature_df,  how='left', on=['SEQN'])
    df_merge = df_merge.replace([np.inf, -np.inf], np.nan)
    df_merge = df_merge.drop('SEQN', 1)
    df_merge = df_merge.dropna()
    df_X = df_merge.drop(target_col, 1)
    df_y = df_merge[[target_col]]
    features = df_X.values
    target_col = df_y.values
    betas = linear_regression_tf(features, target_col)
    return betas 

def linear_regression_tf(features, target_col):
    featuresZ = zscore(features)
    #add bias (also known as intercept)
    featuresZ_pBias = featuresZ
    featuresZ_pBias, target_col = shuffle(featuresZ_pBias, price, random_state=42) 
    #in case order is not random
    n_epochs = 10 
    learning_rate = 0.0001
    penalty = tf.constant(1.0, dtype=tf.float32, name = "penalty")
    momentum_parameter = 0.9
    X = tf.constant(featuresZ_pBias, dtype=tf.float32, name="X")
    y = tf.constant(target_col.reshape(-1,1), dtype=tf.float32, name="y")

    beta = tf.Variable(tf.random_uniform([featuresZ_pBias.shape[1], 1], -1., 1.), name = "beta")
    y_predictions = tf.matmul(X, beta)

    # calculated as a function of Y_predictions and actual Y 
    # Squared error used here 

    penalizedCost = tf.reduce_sum(tf.square(y - y_predictions))

    grads = tf.gradients(penalizedCost, [beta])[0]

    # initialize momentum vector 
    momentum_vector = tf.Variable(initial_value=beta * 0, shape = [featuresZ_pBias.shape[1], 1], name = "momentum_vector")

    # Define training operation as described above 

    training_op_1 = tf.assign(momentum_vector, momentum_parameter * momentum_vector + learning_rate * grads)
    training_op_2 = tf.assign(beta, beta-momentum_vector)

    #initialize variables (i.e. beta, momentum_variable)
    init = tf.global_variables_initializer()


    with tf.Session() as sess:
        sess.run(init)
        for epoch in range(n_epochs):
            penalizedCost.eval()
            sess.run(training_op_1)
            sess.run(training_op_2)
        #done training, get final beta: 
        best_beta = beta.eval()
        return best_beta

    
# linear_regression_tf()
if __name__ == "__main__":
    
    target_fname = sys.argv[1]
    feature_fname = sys.argv[2]
    target_col_name = sys.argv[3]
    #input_rdd.take(2)

    df_1 = pd.read_csv(target_fname)
    df_2 = pd.read_csv(feature_fname)
    betas = get_betas_for_df(df_2, df_1,target_col_name )
    print(betas)